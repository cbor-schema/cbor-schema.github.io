<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-json-schema">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.0">
<title data-rh="true">JSON Schema 中文文档 | CBOR Docs</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://docs.cbor.ai/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://docs.cbor.ai/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://docs.cbor.ai/docs/json-schema"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="JSON Schema 中文文档 | CBOR Docs"><meta data-rh="true" name="description" content="本文翻译自：JSON Schema: A Media Type for Describing JSON Documents."><meta data-rh="true" property="og:description" content="本文翻译自：JSON Schema: A Media Type for Describing JSON Documents."><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://docs.cbor.ai/docs/json-schema"><link data-rh="true" rel="alternate" href="https://docs.cbor.ai/docs/json-schema" hreflang="en"><link data-rh="true" rel="alternate" href="https://docs.cbor.ai/docs/json-schema" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.8671cbe4.css">
<link rel="preload" href="/assets/js/runtime~main.cb93afc4.js" as="script">
<link rel="preload" href="/assets/js/main.0fb661d0.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="CBOR Docs" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="CBOR Docs" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">CBOR Docs</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/cbor">Docs</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/cbor-schema/cbor-docs" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/cbor">CBOR 中文文档</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" href="/docs/json-schema">JSON Schema 中文文档</a></li></ul></nav></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">JSON Schema 中文文档</span><meta itemprop="position" content="1"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>JSON Schema 中文文档</h1><p>本文翻译自：<a href="https://json-schema.org/draft/2020-12/json-schema-core.html" target="_blank" rel="noopener noreferrer">JSON Schema: A Media Type for Describing JSON Documents</a>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="摘要abstract">摘要（Abstract）<a href="#摘要abstract" class="hash-link" aria-label="Direct link to 摘要（Abstract）" title="Direct link to 摘要（Abstract）">​</a></h2><details class="details_lb9f alert alert--info details_b_Ee" data-collapsed="true"><summary>Expand original text</summary><div><div class="collapsibleContent_i85q"><p>JSON Schema defines the media type &quot;application/schema+json&quot;, a JSON-based format for describing the structure of JSON data.
JSON Schema asserts what a JSON document must look like, ways to extract information from it, and how to interact with it. The &quot;application/schema-instance+json&quot; media type provides additional feature-rich integration with &quot;application/schema+json&quot; beyond what can be offered for &quot;application/json&quot; documents.</p></div></div></details><p>JSON Schema 定义了媒体类型 <code>application/schema+json</code>，这是一种基于 JSON 的格式，用于描述 JSON 数据的结构。
JSON Schema 定义了 JSON 文档的内容结构，从中提取信息的方法以及如何与其交互。<code>application/schema-instance+json</code> 媒体类型为 <code>application/schema+json</code> 提供了额外的功能丰富的集成，超出了 <code>application/json</code> 文档所能提供的内容。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1-引言introduction">1. 引言（Introduction）<a href="#1-引言introduction" class="hash-link" aria-label="Direct link to 1. 引言（Introduction）" title="Direct link to 1. 引言（Introduction）">​</a></h2><details class="details_lb9f alert alert--info details_b_Ee" data-collapsed="true"><summary>Expand original text</summary><div><div class="collapsibleContent_i85q"><p>JSON Schema is a JSON media type for defining the structure of JSON data. JSON Schema is intended to define validation, documentation, hyperlink navigation, and interaction control of JSON data.</p><p>This specification defines JSON Schema core terminology and mechanisms, including pointing to another JSON Schema by reference, dereferencing a JSON Schema reference, specifying the dialect being used, specifying a dialect&#x27;s vocabulary requirements, and defining the expected output.</p><p>Other specifications define the vocabularies that perform assertions about validation, linking, annotation, navigation, and interaction.</p></div></div></details><p>JSON Schema 是一种用于定义 JSON 数据结构的 JSON 媒体类型。JSON Schema 旨在定义 JSON 数据的验证、文档、超链接导航和交互控制。</p><p>本规范定义了 JSON Schema 核心术语和机制，包括通过引用指向另一个 JSON Schema、取消引用 JSON Schema 引用、指定正在使用的方言（dialect）、指定方言的词汇表（vocabulary）要求以及定义预期输出。</p><p>其他规范定义了用于执行关于验证（validation）、链接（linking）、注释（annotation）、导航（navigation）和交互（interaction）的断言的词汇表。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2-约定和术语conventions-and-terminology">2. 约定和术语（Conventions and Terminology）<a href="#2-约定和术语conventions-and-terminology" class="hash-link" aria-label="Direct link to 2. 约定和术语（Conventions and Terminology）" title="Direct link to 2. 约定和术语（Conventions and Terminology）">​</a></h2><details class="details_lb9f alert alert--info details_b_Ee" data-collapsed="true"><summary>Expand original text</summary><div><div class="collapsibleContent_i85q"><p>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this document are to be interpreted as described in <a href="https://www.rfc-editor.org/info/rfc2119" target="_blank" rel="noopener noreferrer">RFC 2119</a>.</p><p>The terms &quot;JSON&quot;, &quot;JSON text&quot;, &quot;JSON value&quot;, &quot;member&quot;, &quot;element&quot;, &quot;object&quot;, &quot;array&quot;, &quot;number&quot;, &quot;string&quot;, &quot;boolean&quot;, &quot;true&quot;, &quot;false&quot;, and &quot;null&quot; in this document are to be interpreted as defined in <a href="https://www.rfc-editor.org/info/rfc8259" target="_blank" rel="noopener noreferrer">RFC 8259</a>.</p></div></div></details><p>本文档中的关键词 &quot;必须&quot;（MUST），&quot;必须不&quot;（MUST NOT），&quot;要求&quot;（REQUIRED），&quot;应&quot;（SHALL），&quot;不应&quot;（SHALL NOT），&quot;应该&quot;（SHOULD），&quot;不应该&quot;（SHOULD NOT），&quot;建议&quot;（RECOMMENDED），&quot;可以&quot;（MAY）和 &quot;可选&quot;（OPTIONAL）应按照 <a href="https://www.rfc-editor.org/info/rfc2119" target="_blank" rel="noopener noreferrer">RFC 2119</a> 中的描述进行解释。</p><p>本文档中的术语 &quot;JSON&quot;、&quot;JSON text&quot;、&quot;JSON value&quot;、&quot;member&quot;、&quot;element&quot;、&quot;object&quot;、&quot;array&quot;、&quot;number&quot;、&quot;string&quot;、&quot;boolean&quot;、&quot;true&quot;、&quot;false&quot; 和 &quot;null&quot; 应按照 <a href="https://www.rfc-editor.org/info/rfc8259" target="_blank" rel="noopener noreferrer">RFC 8259</a> 中的定义进行解释。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="3-概述overview">3. 概述（Overview）<a href="#3-概述overview" class="hash-link" aria-label="Direct link to 3. 概述（Overview）" title="Direct link to 3. 概述（Overview）">​</a></h2><details class="details_lb9f alert alert--info details_b_Ee" data-collapsed="true"><summary>Expand original text</summary><div><div class="collapsibleContent_i85q"><p>This document proposes a new media type &quot;application/schema+json&quot; to identify a JSON Schema for describing JSON data. It also proposes a further optional media type, &quot;application/schema-instance+json&quot;, to provide additional integration features. JSON Schemas are themselves JSON documents. This, and related specifications, define keywords allowing authors to describe JSON data in several ways.</p><p>JSON Schema uses keywords to assert constraints on JSON instances or annotate those instances with additional information. Additional keywords are used to apply assertions and annotations to more complex JSON data structures, or based on some sort of condition.</p><p>To facilitate re-use, keywords can be organized into vocabularies. A vocabulary consists of a list of keywords, together with their syntax and semantics. A dialect is defined as a set of vocabularies and their required support identified in a meta-schema.</p><p>JSON Schema can be extended either by defining additional vocabularies, or less formally by defining additional keywords outside of any vocabulary. Unrecognized individual keywords simply have their values collected as annotations, while the behavior with respect to an unrecognized vocabulary can be controlled when declaring which vocabularies are in use.</p><p>This document defines a core vocabulary that MUST be supported by any implementation, and cannot be disabled. Its keywords are each prefixed with a &quot;$&quot; character to emphasize their required nature. This vocabulary is essential to the functioning of the &quot;application/schema+json&quot; media type, and is used to bootstrap the loading of other vocabularies.</p><p>Additionally, this document defines a RECOMMENDED vocabulary of keywords for applying subschemas conditionally, and for applying subschemas to the contents of objects and arrays. Either this vocabulary or one very much like it is required to write schemas for non-trivial JSON instances, whether those schemas are intended for assertion validation, annotation, or both. While not part of the required core vocabulary, for maximum interoperability this additional vocabulary is included in this document and its use is strongly encouraged.</p><p>Further vocabularies for purposes such as structural validation or hypermedia annotation are defined in other documents. These other documents each define a dialect collecting the standard sets of vocabularies needed to write schemas for that document&#x27;s purpose.</p></div></div></details><p>本文档提议一种新的媒体类型 <code>application/schema+json</code>，用于标识描述 JSON 数据的 JSON 模式。它还提议了另一种可选的媒体类型 <code>application/schema-instance+json</code>，以提供其他集成功能。JSON 模式本身是 JSON 文档。此类及相关规范定义了允许作者以多种方式描述 JSON 数据的关键字。</p><p>JSON Schema 使用关键字对 JSON 实例进行约束或用附加信息对这些实例进行注释。其他关键字用于对更复杂的 JSON 数据结构应用断言和注释，或基于某种条件。</p><p>为了便于重用，关键字可以组织成词汇表。一个词汇表由一组关键字及其语法和语义组成。一种方言被定义为一组词汇表及其在元模式中确定的所需支持。</p><p>JSON Schema 可以通过定义额外的词汇表或者在词汇表之外非正式地定义额外的关键字来扩展。无法识别的单个关键字会将其值作为注释收集，而在声明正在使用的词汇表时，可以控制对无法识别的词汇表的行为。</p><p>本文档定义了一个核心词汇表，必须由任何实现支持，并且不能被禁用。其关键字都以 &quot;$&quot; 字符为前缀，以强调其必需性。这个词汇表对于 &quot;application/schema+json&quot; 媒体类型的功能至关重要，并用于引导其他词汇表的加载。</p><p>此外，本文档定义了一个建议的关键字词汇表，用于有条件地应用子模式，以及将子模式应用于对象和数组的内容。为了编写用于断言验证、注释或两者兼而有之的非平凡 JSON 实例的模式，需要使用这个词汇表或类似的词汇表。虽然不是必需的核心词汇表的一部分，但为了最大的互操作性，本文档包含了这个附加词汇表，并强烈推荐使用。</p><p>其他文档中定义了用于结构验证或超媒体注释等目的的更多词汇表。这些其他文档中的每一个都定义了一个方言，收集编写用于该文档目的的模式所需的标准词汇表集合。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="4-定义definitions">4. 定义（Definitions）<a href="#4-定义definitions" class="hash-link" aria-label="Direct link to 4. 定义（Definitions）" title="Direct link to 4. 定义（Definitions）">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="41-json-文档">4.1 JSON 文档<a href="#41-json-文档" class="hash-link" aria-label="Direct link to 4.1 JSON 文档" title="Direct link to 4.1 JSON 文档">​</a></h3><details class="details_lb9f alert alert--info details_b_Ee" data-collapsed="true"><summary>Expand original text</summary><div><div class="collapsibleContent_i85q"><p>A JSON document is an information resource (series of octets) described by the application/json media type.</p><p>In JSON Schema, the terms &quot;JSON document&quot;, &quot;JSON text&quot;, and &quot;JSON value&quot; are interchangeable because of the data model it defines.</p><p>JSON Schema is only defined over JSON documents. However, any document or memory structure that can be parsed into or processed according to the JSON Schema data model can be interpreted against a JSON Schema, including media types like <a href="https://www.rfc-editor.org/info/rfc8949" target="_blank" rel="noopener noreferrer">CBOR</a>.</p></div></div></details><p>JSON 文档是一个由 application/json 媒体类型描述的信息资源（一系列八位字节组）。
在 JSON Schema 中，术语 &quot;JSON 文档&quot;、&quot;JSON 文本&quot; 和 &quot;JSON 值&quot; 是可以互换的，因为它定义了数据模型。</p><p>JSON Schema 只针对 JSON 文档进行定义。然而，任何可以解析为 JSON Schema 数据模型的文档或内存结构都可以根据 JSON Schema 进行解释，包括像 <a href="https://www.rfc-editor.org/info/rfc8949" target="_blank" rel="noopener noreferrer">CBOR</a> 这样的媒体类型。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="42-实例instance">4.2 实例（Instance）<a href="#42-实例instance" class="hash-link" aria-label="Direct link to 4.2 实例（Instance）" title="Direct link to 4.2 实例（Instance）">​</a></h3><details class="details_lb9f alert alert--info details_b_Ee" data-collapsed="true"><summary>Expand original text</summary><div><div class="collapsibleContent_i85q"><p>A JSON document to which a schema is applied is known as an &quot;instance&quot;.</p><p>JSON Schema is defined over &quot;application/json&quot; or compatible documents, including media types with the &quot;+json&quot; structured syntax suffix.</p><p>Among these, this specification defines the &quot;application/schema-instance+json&quot; media type which defines handling for fragments in the URI.</p></div></div></details><p>应用了一个模式的 JSON 文档被称为 &quot;实例&quot;。</p><p>JSON Schema 是针对 <code>application/json</code> 或兼容文档定义的，包括具有 <code>+json</code> 结构化语法后缀的媒体类型。</p><p>在这些媒体类型中，本规范定义了 <code>application/schema-instance+json</code> 媒体类型，它为 URI 中的片段定义了处理规则。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="421-实例数据模型instance-data-model">4.2.1 实例数据模型（Instance Data Model）<a href="#421-实例数据模型instance-data-model" class="hash-link" aria-label="Direct link to 4.2.1 实例数据模型（Instance Data Model）" title="Direct link to 4.2.1 实例数据模型（Instance Data Model）">​</a></h4><details class="details_lb9f alert alert--info details_b_Ee" data-collapsed="true"><summary>Expand original text</summary><div><div class="collapsibleContent_i85q"><p>JSON Schema interprets documents according to a data model. A JSON value interpreted according to this data model is called an &quot;instance&quot;.</p><p>An instance has one of six primitive types, and a range of possible values depending on the type:</p><ul><li>null: A JSON &quot;null&quot; value</li><li>boolean: A &quot;true&quot; or &quot;false&quot; value, from the JSON &quot;true&quot; or &quot;false&quot; value</li><li>object: An unordered set of properties mapping a string to an instance, from the JSON &quot;object&quot; value</li><li>array: An ordered list of instances, from the JSON &quot;array&quot; value</li><li>number: An arbitrary-precision, base-10 decimal number value, from the JSON &quot;number&quot; value</li><li>string: A string of Unicode code points, from the JSON &quot;string&quot; value</li></ul><p>Whitespace and formatting concerns, including different lexical representations of numbers that are equal within the data model, are thus outside the scope of JSON Schema. JSON Schema vocabularies (Section 8.1) that wish to work with such differences in lexical representations SHOULD define keywords to precisely interpret formatted strings within the data model rather than relying on having the original JSON representation Unicode characters available.</p><p>Since an object cannot have two properties with the same key, behavior for a JSON document that tries to define two properties with the same key in a single object is undefined.</p><p>Note that JSON Schema vocabularies are free to define their own extended type system. This should not be confused with the core data model types defined here. As an example, &quot;integer&quot; is a reasonable type for a vocabulary to define as a value for a keyword, but the data model makes no distinction between integers and other numbers.</p></div></div></details><p>JSON Schema 根据数据模型解释文档。根据这个数据模型解释的 JSON 值被称为 &quot;实例&quot;。</p><p>实例有六种基本类型，取决于类型，可以有一系列可能的值：</p><ul><li><code>null</code>：JSON &quot;null&quot; 值</li><li><code>boolean</code>：JSON &quot;true&quot; 或 &quot;false&quot; 值的 &quot;true&quot; 或 &quot;false&quot; 值</li><li><code>object</code>：一个将字符串映射到实例的无序属性集，来自 JSON &quot;object&quot; 值</li><li><code>array</code>：实例的有序列表，来自 JSON &quot;array&quot; 值</li><li><code>number</code>：任意精度、基数为10的十进制数字值，来自 JSON &quot;number&quot; 值</li><li><code>string</code>：Unicode 代码点的字符串，来自 JSON &quot;string&quot; 值</li></ul><p>因此，空白和格式问题（例如，数据模型中相等的数字的不同词法表示）不在 JSON Schema 的范围内。希望处理词法表示差异的 JSON Schema 词汇表（第 8.1 节）应该定义关键字，以便在数据模型中精确解释格式化字符串，而不是依赖于原始 JSON 表示的 Unicode 字符。</p><p>由于对象不能有两个具有相同键的属性，所以在单个对象中尝试定义两个具有相同键的属性的 JSON 文档的行为是未定义的。</p><p>请注意，JSON Schema 词汇表可以自由地定义自己的扩展类型系统。这不应与此处定义的核心数据模型类型混淆。例如，&quot;integer&quot; 是一个合理的类型，词汇表可以将其定义为关键字的值，但数据模型不区分整数和其他数字。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="422-实例相等instance-equality">4.2.2 实例相等（Instance Equality）<a href="#422-实例相等instance-equality" class="hash-link" aria-label="Direct link to 4.2.2 实例相等（Instance Equality）" title="Direct link to 4.2.2 实例相等（Instance Equality）">​</a></h4><details class="details_lb9f alert alert--info details_b_Ee" data-collapsed="true"><summary>Expand original text</summary><div><div class="collapsibleContent_i85q"><p>Two JSON instances are said to be equal if and only if they are of the same type and have the same value according to the data model. Specifically, this means:</p><div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">both are null; or</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">both are true; or</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">both are false; or</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">both are strings, and are the same codepoint-for-codepoint; or</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">both are numbers, and have the same mathematical value; or</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">both are arrays, and have an equal value item-for-item; or</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">both are objects, and each property in one has exactly one property with a key equal to the other&#x27;s, and that other property has an equal value.</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Implied in this definition is that arrays must be the same length, objects must have the same number of members, properties in objects are unordered, there is no way to define multiple properties with the same key, and mere formatting differences (indentation, placement of commas, trailing zeros) are insignificant.</p></div></div></details><p>如果两个 JSON 实例具有相同的类型，并根据数据模型具有相同的值，则它们被认为是相等的。具体来说，这意味着：</p><div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">两者都是 null；或</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">两者都是 true；或</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">两者都是 false；或</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">两者都是字符串，并且在每个代码点上相同；或</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">两者都是数字，并具有相同的数学值；或</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">两者都是数组，并且按项具有相等的值；或</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">两者都是对象，并且其中一个对象的每个属性都有一个键等于另一个对象的属性，且另一个属性具有相等的值</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这个定义暗示，数组必须具有相同的长度，对象必须具有相同数量的成员，对象中的属性是无序的，不能定义具有相同键的多个属性，仅格式差异（缩进、逗号位置、尾随零）是无关紧要的。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="423-非-json-实例non-json-instances">4.2.3 非 JSON 实例（Non-JSON Instances）<a href="#423-非-json-实例non-json-instances" class="hash-link" aria-label="Direct link to 4.2.3 非 JSON 实例（Non-JSON Instances）" title="Direct link to 4.2.3 非 JSON 实例（Non-JSON Instances）">​</a></h4><details class="details_lb9f alert alert--info details_b_Ee" data-collapsed="true"><summary>Expand original text</summary><div><div class="collapsibleContent_i85q"><p>It is possible to use JSON Schema with a superset of the JSON Schema data model, where an instance may be outside any of the six JSON data types.</p><p>In this case, annotations still apply; but most validation keywords will not be useful, as they will always pass or always fail.</p><p>A custom vocabulary may define support for a superset of the core data model. The schema itself may only be expressible in this superset; for example, to make use of the &quot;const&quot; keyword.</p></div></div></details><p>可以在 JSON Schema 数据模型的超集中使用 JSON Schema，其中实例可能超出 JSON 的六种数据类型之外。</p><p>在这种情况下，注释仍然适用；但大多数验证关键字可能没有用处，因为它们总是通过或总是失败。</p><p>自定义词汇表可以定义对核心数据模型的超集的支持。模式本身可能只能在这个超集中表示；例如，使用 <code>const</code> 关键字。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="43-json-schema-文档">4.3. JSON Schema 文档<a href="#43-json-schema-文档" class="hash-link" aria-label="Direct link to 4.3. JSON Schema 文档" title="Direct link to 4.3. JSON Schema 文档">​</a></h3><details class="details_lb9f alert alert--info details_b_Ee" data-collapsed="true"><summary>Expand original text</summary><div><div class="collapsibleContent_i85q"><p>A JSON Schema document, or simply a schema, is a JSON document used to describe an instance. A schema can itself be interpreted as an instance, but SHOULD always be given the media type &quot;application/schema+json&quot; rather than &quot;application/schema-instance+json&quot;. The &quot;application/schema+json&quot; media type is defined to offer a superset of the fragment identifier syntax and semantics provided by &quot;application/schema-instance+json&quot;.</p><p>A JSON Schema MUST be an object or a boolean.</p></div></div></details><p>JSON Schema 文档，或简称为模式，是用于描述实例的 JSON 文档。模式本身可以被解释为实例，但应始终使用媒体类型 <code>application/schema+json</code> 而不是 <code>application/schema-instance+json</code>。<code>application/schema+json</code> 媒体类型被定义为提供超过 <code>application/schema-instance+json</code> 提供的片段标识符语法和语义的超集。</p><p>JSON Schema 必须是一个对象（object）或布尔值（boolean）。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="431-json-schema-对象objects和关键字keywords">4.3.1. JSON Schema 对象（Objects）和关键字（Keywords）<a href="#431-json-schema-对象objects和关键字keywords" class="hash-link" aria-label="Direct link to 4.3.1. JSON Schema 对象（Objects）和关键字（Keywords）" title="Direct link to 4.3.1. JSON Schema 对象（Objects）和关键字（Keywords）">​</a></h4><details class="details_lb9f alert alert--info details_b_Ee" data-collapsed="true"><summary>Expand original text</summary><div><div class="collapsibleContent_i85q">Object properties that are applied to the instance are called keywords, or schema keywords. Broadly speaking, keywords fall into one of five categories:<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">identifiers: control schema identification through setting a URI for the schema and/or changing how the base URI is determined</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">assertions: produce a boolean result when applied to an instance</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">annotations: attach information to an instance for application use</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">applicators: apply one or more subschemas to a particular location in the instance, and combine or modify their results</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">reserved locations: do not directly affect results, but reserve a place for a specific purpose to ensure interoperability</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Keywords may fall into multiple categories, although applicators SHOULD only produce assertion results based on their subschemas&#x27; results. They should not define additional constraints independent of their subschemas.</p><p>Keywords which are properties within the same schema object are referred to as adjacent keywords.</p><p>Extension keywords, meaning those defined outside of this document and its companions, are free to define other behaviors as well.</p><p>A JSON Schema MAY contain properties which are not schema keywords. Unknown keywords SHOULD be treated as annotations, where the value of the keyword is the value of the annotation.</p><p>An empty schema is a JSON Schema with no properties, or only unknown properties.</p></div></div></details><p>应用于实例的对象属性称为关键字或模式关键字。大致上，关键字可分为五类：</p><div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">标识符（identifiers）：通过为模式设置 URI 和/或更改基本 URI 的确定方式来控制模式识别</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">断言（assertions）：在应用于实例时产生布尔结果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">注解（annotations）：为应用程序使用附加信息到实例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">修改器（applicators）：将一个或多个子模式应用于实例中的特定位置，并组合或修改它们的结果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">保留位置（reserved locations）：不直接影响结果，但为确保互操作性保留一个特定目的的位置</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>关键字可能属于多个类别，尽管应用程序应仅根据其子模式的结果产生断言结果。它们不应定义与其子模式无关的其他约束。</p><p>在同一模式对象中的属性的关键字被称为相邻关键字。</p><p>扩展关键字，即在本文档及其附件之外定义的关键字，也可以自由定义其他行为。</p><p>JSON Schema 可能包含非模式关键字的属性。未知关键字应被视为注解，其中关键字的值是注解的值。</p><p>空模式是一个没有属性或只有未知属性的 JSON Schema。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="432-布尔-json-schemas">4.3.2. 布尔 JSON Schemas<a href="#432-布尔-json-schemas" class="hash-link" aria-label="Direct link to 4.3.2. 布尔 JSON Schemas" title="Direct link to 4.3.2. 布尔 JSON Schemas">​</a></h4><details class="details_lb9f alert alert--info details_b_Ee" data-collapsed="true"><summary>Expand original text</summary><div><div class="collapsibleContent_i85q"><p>The boolean schema values &quot;true&quot; and &quot;false&quot; are trivial schemas that always produce themselves as assertion results, regardless of the instance value. They never produce annotation results.</p><p>These boolean schemas exist to clarify schema author intent and facilitate schema processing optimizations. They behave identically to the following schema objects (where &quot;not&quot; is part of the subschema application vocabulary defined in this document).</p><div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">true: Always passes validation, as if the empty schema {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">false: Always fails validation, as if the schema { &quot;not&quot;: {} }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>While the empty schema object is unambiguous, there are many possible equivalents to the &quot;false&quot; schema. Using the boolean values ensures that the intent is clear to both human readers and implementations.</p></div></div></details><p>布尔模式值 &quot;true&quot; 和 &quot;false&quot; 是始终产生它们自身作为断言结果的简单模式，无论实例值如何。它们从不产生注解结果。</p><p>这些布尔模式存在是为了澄清模式作者的意图并促进模式处理优化。它们的行为与以下模式对象完全相同（其中 &quot;not&quot; 是本文档中定义的子模式应用词汇的一部分）。</p><div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">`true`：始终通过验证，就像空模式 `{}` 一样</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">`false`：始终无法通过验证，就像模式 `{ &quot;not&quot;: {} }` 一样</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>虽然空模式对象是明确的，但与 &quot;false&quot; 模式等价的可能有很多。使用布尔值确保意图对人类阅读者和实现都是清晰的。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="433-模式词汇表schema-vocabularies">4.3.3. 模式词汇表（Schema Vocabularies）<a href="#433-模式词汇表schema-vocabularies" class="hash-link" aria-label="Direct link to 4.3.3. 模式词汇表（Schema Vocabularies）" title="Direct link to 4.3.3. 模式词汇表（Schema Vocabularies）">​</a></h4><details class="details_lb9f alert alert--info details_b_Ee" data-collapsed="true"><summary>Expand original text</summary><div><div class="collapsibleContent_i85q">A schema vocabulary, or simply a vocabulary, is a set of keywords, their syntax, and their semantics. A vocabulary is generally organized around a particular purpose. Different uses of JSON Schema, such as validation, hypermedia, or user interface generation, will involve different sets of vocabularies.<p>Vocabularies are the primary unit of re-use in JSON Schema, as schema authors can indicate what vocabularies are required or optional in order to process the schema. Since vocabularies are identified by URIs in the meta-schema, generic implementations can load extensions to support previously unknown vocabularies. While keywords can be supported outside of any vocabulary, there is no analogous mechanism to indicate individual keyword usage.</p><p>A schema vocabulary can be defined by anything from an informal description to a standards proposal, depending on the audience and interoperability expectations. In particular, in order to facilitate vocabulary use within non-public organizations, a vocabulary specification need not be published outside of its scope of use.</p></div></div></details><p>模式词汇表，或简称为词汇表，是一组关键字、它们的语法和语义。词汇表通常围绕特定目的组织。JSON Schema 的不同用途，如验证、超媒体或用户界面生成，将涉及不同的词汇表集合。</p><p>词汇表是 JSON Schema 中主要的可重用单元，因为模式作者可以指示处理模式所需或可选的词汇表。由于元模式中的词汇表由 URI 标识，通用实现可以加载扩展以支持以前未知的词汇表。虽然关键字可以在任何词汇表之外得到支持，但没有类似的机制来指示单个关键字的使用。</p><p>模式词汇表可以由从非正式描述到标准提案的任何内容定义，具体取决于受众和互操作性期望。特别是为了促进非公共组织内的词汇表使用，词汇表规范不需要在其使用范围之外发布。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="434-元模式meta-schemas">4.3.4. 元模式（Meta-Schemas）<a href="#434-元模式meta-schemas" class="hash-link" aria-label="Direct link to 4.3.4. 元模式（Meta-Schemas）" title="Direct link to 4.3.4. 元模式（Meta-Schemas）">​</a></h4><details class="details_lb9f alert alert--info details_b_Ee" data-collapsed="true"><summary>Expand original text</summary><div><div class="collapsibleContent_i85q"><p>4.3.4. Meta-Schemas
A schema that itself describes a schema is called a meta-schema. Meta-schemas are used to validate JSON Schemas and specify which vocabularies they are using.</p><p>Typically, a meta-schema will specify a set of vocabularies, and validate schemas that conform to the syntax of those vocabularies. However, meta-schemas and vocabularies are separate in order to allow meta-schemas to validate schema conformance more strictly or more loosely than the vocabularies&#x27; specifications call for. Meta-schemas may also describe and validate additional keywords that are not part of a formal vocabulary.</p></div></div></details><p>用来描述模式的模式被称为元模式。元模式用于验证 JSON 模式并指定它们正在使用的词汇表。</p><p>通常，元模式会指定一组词汇表，并验证符合这些词汇表语法的模式。然而，元模式和词汇表是分开的，以便允许元模式比词汇表的规范要求更严格或更宽松地验证模式一致性。元模式还可以描述和验证不属于正式词汇表的额外关键字。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="435-根模式子模式和资源root-schema-and-subschemas-and-resources">4.3.5. 根模式、子模式和资源（Root Schema and Subschemas and Resources）<a href="#435-根模式子模式和资源root-schema-and-subschemas-and-resources" class="hash-link" aria-label="Direct link to 4.3.5. 根模式、子模式和资源（Root Schema and Subschemas and Resources）" title="Direct link to 4.3.5. 根模式、子模式和资源（Root Schema and Subschemas and Resources）">​</a></h4><details class="details_lb9f alert alert--info details_b_Ee" data-collapsed="true"><summary>Expand original text</summary><div><div class="collapsibleContent_i85q">A JSON Schema resource is a schema which is canonically [RFC6596] identified by an absolute URI [RFC3986]. Schema resources MAY also be identified by URIs, including URIs with fragments, if the resulting secondary resource (as defined by section 3.5 of RFC 3986 [RFC3986]) is identical to the primary resource. This can occur with the empty fragment, or when one schema resource is embedded in another. Any such URIs with fragments are considered to be non-canonical.<p>The root schema is the schema that comprises the entire JSON document in question. The root schema is always a schema resource, where the URI is determined as described in section 9.1.1. Note that documents that embed schemas in another format will not have a root schema resource in this sense. Exactly how such usages fit with the JSON Schema document and resource concepts will be clarified in a future draft.</p><p>Some keywords take schemas themselves, allowing JSON Schemas to be nested:</p><div class="language-json codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-json codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token property" style="color:#36acaa">&quot;title&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;root&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token property" style="color:#36acaa">&quot;items&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token property" style="color:#36acaa">&quot;title&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;array item&quot;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>In this example document, the schema titled &quot;array item&quot; is a subschema, and the schema titled &quot;root&quot; is the root schema.</p><p>As with the root schema, a subschema is either an object or a boolean.</p><p>As discussed in section 8.2.1, a JSON Schema document can contain multiple JSON Schema resources. When used without qualification, the term &quot;root schema&quot; refers to the document&#x27;s root schema. In some cases, resource root schemas are discussed. A resource&#x27;s root schema is its top-level schema object, which would also be a document root schema if the resource were to be extracted to a standalone JSON Schema document.</p><p>Whether multiple schema resources are embedded or linked with a reference, they are processed in the same way, with the same available behaviors.</p></div></div></details><p>JSON Schema 资源是由绝对 URI <a href="https://www.rfc-editor.org/info/rfc3986" target="_blank" rel="noopener noreferrer">RFC 3986</a> 规范化 <a href="https://www.rfc-editor.org/info/rfc6596" target="_blank" rel="noopener noreferrer">RFC 6596</a> 标识的模式。模式资源还可以通过 URI 标识，包括带有片段的 URI，如果由此产生的辅助资源（如 <a href="https://www.rfc-editor.org/info/rfc3986" target="_blank" rel="noopener noreferrer">RFC 3986</a> 第 3.5 节定义的）与主资源相同。这可以发生在空片段中，或者当一个模式资源嵌入到另一个模式资源中。任何这样的带有片段的 URI 都被认为是非规范的。</p><p>根模式是组成整个 JSON 文档的模式。根模式始终是一个模式资源，URI 是按照第 9.1.1 节的描述确定的。请注意，将模式嵌入到其他格式的文档在这个意义上不会有一个根模式资源。这种用法与 JSON Schema 文档和资源概念如何适应将在未来的草案中得到澄清。</p><p>某些关键字本身采用模式，允许 JSON 模式嵌套：</p><div class="language-json codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-json codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token property" style="color:#36acaa">&quot;title&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;root&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token property" style="color:#36acaa">&quot;items&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token property" style="color:#36acaa">&quot;title&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;array item&quot;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在这个示例文档中，标题为 &quot;array item&quot; 的模式是一个子模式，标题为 &quot;root&quot; 的模式是根模式。</p><p>与根模式一样，子模式可以是对象或布尔值。</p><p>如第 8.2.1 节所讨论的，一个 JSON Schema 文档可以包含多个 JSON Schema 资源。在未经限定的情况下使用术语 &quot;根模式&quot; 是指文档的根模式。在某些情况下，讨论了资源的根模式。资源的根模式是其顶级模式对象，如果资源被提取到一个独立的 JSON Schema 文档中，它也将成为一个文档根模式。</p><p>无论是嵌入多个模式资源还是通过引用链接它们，它们都以相同的方式进行处理，具有相同的可用行为。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="5-片段标识符fragment-identifiers">5. 片段标识符（Fragment Identifiers）<a href="#5-片段标识符fragment-identifiers" class="hash-link" aria-label="Direct link to 5. 片段标识符（Fragment Identifiers）" title="Direct link to 5. 片段标识符（Fragment Identifiers）">​</a></h2><details class="details_lb9f alert alert--info details_b_Ee" data-collapsed="true"><summary>Expand original text</summary><div><div class="collapsibleContent_i85q"><p>In accordance with section 3.1 of <a href="https://www.rfc-editor.org/info/rfc6839" target="_blank" rel="noopener noreferrer">RFC 6839</a>, the syntax and semantics of fragment identifiers specified for any +json media type SHOULD be as specified for &quot;application/json&quot;. (At publication of this document, there is no fragment identification syntax defined for &quot;application/json&quot;.)</p><p>Additionally, the &quot;application/schema+json&quot; media type supports two fragment identifier structures: plain names and JSON Pointers. The &quot;application/schema-instance+json&quot; media type supports one fragment identifier structure: JSON Pointers.</p><p>The use of JSON Pointers as URI fragment identifiers is described in <a href="https://www.rfc-editor.org/info/rfc6901" target="_blank" rel="noopener noreferrer">RFC 6901</a>. For &quot;application/schema+json&quot;, which supports two fragment identifier syntaxes, fragment identifiers matching the JSON Pointer syntax, including the empty string, MUST be interpreted as JSON Pointer fragment identifiers.</p><p>Per the W3C&#x27;s best practices for fragment identifiers <a href="https://www.w3.org/TR/2012/WD-fragid-best-practices-20121025" target="_blank" rel="noopener noreferrer">W3C.WD-fragid-best-practices-20121025</a>, plain name fragment identifiers in &quot;application/schema+json&quot; are reserved for referencing locally named schemas. All fragment identifiers that do not match the JSON Pointer syntax MUST be interpreted as plain name fragment identifiers.</p><p>Defining and referencing a plain name fragment identifier within an &quot;application/schema+json&quot; document are specified in the &quot;$anchor&quot; keyword (Section 8.2.2) section.</p></div></div></details><p>根据 <a href="https://www.rfc-editor.org/info/rfc6839" target="_blank" rel="noopener noreferrer">RFC 6839</a> 第 3.1 节的规定，任何 <code>+json</code> 媒体类型的片段标识符的语法和语义应与 <code>application/json</code> 的规定相同。（在本文档发布时，尚未为 &quot;application/json&quot; 定义片段标识符语法。）
此外，<code>application/schema+json</code> 媒体类型支持两种片段标识符结构：纯名称和 JSON 指针。<code>application/schema-instance+json</code> 媒体类型支持一种片段标识符结构：JSON 指针。</p><p>在 <a href="https://www.rfc-editor.org/info/rfc6901" target="_blank" rel="noopener noreferrer">RFC 6901</a> 中描述了将 JSON 指针用作 URI 片段标识符。对于 <code>application/schema+json</code>，它支持两种片段标识符语法，匹配 JSON 指针语法的片段标识符（包括空字符串）必须被解释为 JSON 指针片段标识符。</p><p>根据 W3C 关于片段标识符的最佳实践 <a href="https://www.w3.org/TR/2012/WD-fragid-best-practices-20121025" target="_blank" rel="noopener noreferrer">W3C.WD-fragid-best-practices-20121025</a>，<code>application/schema+json</code> 中的纯名称片段标识符保留用于引用本地命名的模式。所有不符合 JSON 指针语法的片段标识符必须被解释为纯名称片段标识符。</p><p>在 <code>application/schema+json</code> 文档中定义和引用纯名称片段标识符的规定在 <code>$anchor</code> 关键字（第 8.2.2 节）部分。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/cbor-schema/cbor-docs/tree/main/docs/json-schema.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/cbor"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">CBOR 中文文档</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#摘要abstract" class="table-of-contents__link toc-highlight">摘要（Abstract）</a></li><li><a href="#1-引言introduction" class="table-of-contents__link toc-highlight">1. 引言（Introduction）</a></li><li><a href="#2-约定和术语conventions-and-terminology" class="table-of-contents__link toc-highlight">2. 约定和术语（Conventions and Terminology）</a></li><li><a href="#3-概述overview" class="table-of-contents__link toc-highlight">3. 概述（Overview）</a></li><li><a href="#4-定义definitions" class="table-of-contents__link toc-highlight">4. 定义（Definitions）</a><ul><li><a href="#41-json-文档" class="table-of-contents__link toc-highlight">4.1 JSON 文档</a></li><li><a href="#42-实例instance" class="table-of-contents__link toc-highlight">4.2 实例（Instance）</a></li><li><a href="#43-json-schema-文档" class="table-of-contents__link toc-highlight">4.3. JSON Schema 文档</a></li></ul></li><li><a href="#5-片段标识符fragment-identifiers" class="table-of-contents__link toc-highlight">5. 片段标识符（Fragment Identifiers）</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs">Docs</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/cbor-schema/cbor-docs/issues" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub Issues<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/cbor-schema/cbor-docs" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 CBOR Schema Group. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.cb93afc4.js"></script>
<script src="/assets/js/main.0fb661d0.js"></script>
</body>
</html>